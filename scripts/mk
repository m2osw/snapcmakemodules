#!/bin/bash
#
# Sample script to run make without having to retype the long path each time
# This will work if you built the environment using our ~/bin/build-snap script

if test ! -d debian
then
	echo "error: this script is expected to be run from the top folder of a project (where the debian folder appears)."
	exit 1
fi

if test "`whoami`" = "root"
then
	echo "error: this script cannot be run as root."
	exit 1
fi


FULL_VERSION=`dpkg-parsechangelog --show-field Version | sed -e 's/~.*//' -e 's/\(^[0-9]\+\.[0-9]\+\.[0-9]\+.[0-9]\+\).*/\1/'`
DOC_VERSION=`echo ${FULL_VERSION} | sed -e 's/\(^[0-9]\+\.[0-9]\+\).*/\1/'`
SOURCE=`pwd`
PROJECT=`basename ${SOURCE}`
PROCESSORS=`nproc`
PARENTDIR=`dirname ${SOURCE}`
PARENTNAME=`basename ${PARENTDIR}`
if test "${PARENTNAME}" != "contrib"
then
	CONTRIBDIR=""
	TOPDIR=".."
else
	CONTRIBDIR="contrib/"
	TOPDIR="../.."
fi
BUILD="${TOPDIR}/BUILD"
TYPE="Debug"
TARGET=
LESS=false
DOCS=false
COVERAGE=
TEST=false
TEST_DBG=false
TESTS="${TEST_OPTIONS}"		# TEST_OPTIONS can be defined by the project to add default options to always use along the unittest
TEST_SEED=
LAUNCHPAD=false

# Retrieve the user default PROCESSORS=... and other variables
if test -f ~/.build-snap.rc
then
	. ~/.build-snap.rc
fi

while test -n "${1}"
do
	case ${1} in
	"--clean"|"-k")
		shift
		TARGET=clean
		;;

	"--coverage"|"-c")
		if test ! -d tests
		then
			echo "error: no tests folder detected; option not available."
			exit 1
		fi
		if test -x ../cmake/scripts/coverage
		then
			COVERAGE=../cmake/scripts/coverage
		elif test -x ../../cmake/scripts/coverage
		then
			COVERAGE=../../cmake/scripts/coverage
		else
			echo "error: could not find the coverage script in .../cmake/scripts"
			exit 1
		fi
		shift
		;;

	"--documentation"|"-d")
		if test ! -d doc
		then
			echo "error: doc folder not present; option not available."
			exit 1
		fi
		shift
		DOCS=true
		;;

	"--debug"|"-g")
		shift
		TYPE="Debug"
		;;

	"--help"|"-h")
		echo "Usage: ${0} [-opts]"
		echo "where -opts are:"
		echo "  --clean | -k              Clean the output folder"

		if test -d tests
		then
			echo "  --coverage | -c           Run the tests to determine coverage."
			echo "                            Use -t with -c to only run coverage for those tests."
		fi

		echo "  --documentation | -d      Rebuild the documentation."
		echo "  --debug | -g              Build the Debug version."
		echo "  --help | -h               Print out this help screen."
		echo "  --install | -i            Install once built."
		echo "  --less | -l               Force output through less."

		if test -d debian
		then
			echo "  --packages | -b           Build packages on launchpad."
		fi

		echo "  --processors | -p <count> Change the number of processors."
		echo "  --release | -r            Build the Release version."
		echo "  --sanitize | -s           Build the Sanitized version."

		if test -d tests
		then
			echo "  --seed <seed>             Define the seed."
			echo "  --test | -t [<name> ...]  Build and then run the tests."
			echo "                            Tests names can be written separated by commas"
			echo "                            in which case you cannot include any spaces:"
			echo "                               -t a b c   or   -t a,b,c"
			echo "  --tg [<name> ...]         Like --test but run the tests with the debugger."
		fi

		echo "  --verbose | -v            Render the 'make' tool verbose."
		echo "  --version                 Current version of the project."
		exit 0
		;;

	"--install"|"-i")
		shift
		TARGET=install
		;;

	"--less"|"-l")
		shift
		LESS=true
		;;

	"--packages"|"-b")
		if test ! -d debian
		then
			echo "error: build on launchpad not available, debian folder not found."
			exit 1
		fi
		read -p "Are you sure you are ready to build on Launchpad? (y/[N]) " answer
		if test "${answer}" != "y" -a "${answer}" != "Y"
		then
			echo "warning: the build was not approved."
			exit 1
		fi
		shift
		LAUNCHPAD=true
		;;

	"--processors"|"-p")
		shift
		PROCESSORS="${1}"
		shift
		;;

	"--release"|"-r")
		shift
		TYPE="Release"
		;;

	"--sanitize"|"-s")
		shift
		TYPE="Sanitize"
		;;

	"--seed")
		shift
		TEST_SEED="--seed $1"
		shift
		;;

	"--test"|"-t"|"--tg")
		if test ! -d tests
		then
			echo "error: no tests folder detected; option not available."
			exit 1
		fi
		if test "$1" = "--tg"
		then
			TEST_DBG=true
		fi
		shift
		TEST=true
		while [[ "${1}" != "" && "${1}" != "-"* ]]
		do
			if test -n "${TESTS}"
			then
				TESTS="${TESTS},"
			fi
			TESTS="${TESTS}${1}"
			shift
		done
		;;

	"--verbose"|"-v")
		shift
		export VERBOSE=1
		;;

	"--version")
		echo $FULL_VERSION
		exit 0
		;;

	*)
		echo "error: unknown command line option \"${1}\"."
		exit 1
		;;

	esac
done

if test "${TARGET}" = "clean"
then
	if test -n "${COVERAGE}"
	then
		echo "error: --clean and --coverage can't be used together."
		exit 1
	fi
	if ${TEST}
	then
		echo "error: --clean and --test can't be used together."
		exit 1
	fi
	if ${DOCS}
	then
		echo "error: --clean and --documentation can't be used together."
		exit 1
	fi

	if test -d tmp
	then
		rmdir --ignore-fail-on-non-empty tmp
	fi

	# Also delete the docs so they get rebuilt too
	# (I know the last test above is contradictory...)
	#
	DOCS=true
fi



OUTPUT="${BUILD}/${TYPE}/${CONTRIBDIR}${PROJECT}"
PROJECT_TMPDIR="${BUILD}/${TYPE}/${CONTRIBDIR}${PROJECT}/tmp"


if ${DOCS}
then
	# Delete the existing output folder and the tarball
	#
	rm -rf ${OUTPUT}/doc/${PROJECT}-doc-${DOC_VERSION} \
	       ${OUTPUT}/doc/${PROJECT}-doc-${DOC_VERSION}.tar.gz
fi

if ${LESS}
then
	make -j${PROCESSORS} -C ${OUTPUT} ${TARGET} 2>&1 | less -SR
	RESULT=${PIPESTATUS[0]}
else
	make -j${PROCESSORS} -C ${OUTPUT} ${TARGET}
	RESULT=${?}
fi

if [[ ${RESULT} = 0 ]]
then
	if test -n "${COVERAGE}"
	then
		${COVERAGE} ${TESTS}
		RESULT=${?}
	elif ${TEST}
	then
		echo "${OUTPUT}/tests/unittest --tmp-dir "${PROJECT_TMPDIR}" --source-dir "${SOURCE}" ${PROJECT_TEST_ARGS} ${TEST_SEED} --progress ${TESTS}"
		if ${TEST_DBG}
		then
			gdb -ex 'run' --args ${OUTPUT}/tests/unittest --tmp-dir "${PROJECT_TMPDIR}" --source-dir "${SOURCE}" ${PROJECT_TEST_ARGS} ${TEST_SEED} --progress ${TESTS}

			# the check of the result in this case is not quite relevant
			exit 0
		elif ${LESS}
		then
			${OUTPUT}/tests/unittest --tmp-dir "${PROJECT_TMPDIR}" --source-dir "${SOURCE}" ${PROJECT_TEST_ARGS} ${TEST_SEED} --progress ${TESTS} 2>&1 | less -SR
			RESULT=${PIPESTATUS[0]}
		else
			${OUTPUT}/tests/unittest --tmp-dir "${PROJECT_TMPDIR}" --source-dir "${SOURCE}" ${PROJECT_TEST_ARGS} ${TEST_SEED} --progress ${TESTS}
			RESULT=${?}
		fi
	fi
fi

if [[ ${RESULT} = 0 ]]
then
	if ${LAUNCHPAD}
	then
		cd ${TOPDIR}
		if test ! -d ~/.build-snap.rc
		then
			echo
			echo "warning: no ~/.build-snap.rc file found, send-to-lanchpad.sh may fail"
			echo "warning: because it can't properly sign the source files."
			echo
		fi
		bin/send-to-launchpad.sh ${PROJECT}
	fi
	echo
	echo "Success."
else
	echo
	echo "Build, Tests, or Coverage failed."

	exit 1
fi

